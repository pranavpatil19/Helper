using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DataAccessLayer.SourceGenerators;

[Generator]
public sealed class MapperGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var candidates = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "DataAccessLayer.Mapping.GeneratedMapperAttribute",
                static (node, _) => node is ClassDeclarationSyntax,
                static (ctx, _) => ctx);

        context.RegisterSourceOutput(candidates, static (spc, ctx) =>
        {
            if (ctx.TargetSymbol is not INamedTypeSymbol typeSymbol)
            {
                return;
            }

            var mapperName = GetMapperName(ctx);
            var source = GenerateMapperSource(typeSymbol, mapperName);
            spc.AddSource($"{mapperName}.g.cs", source);
        });
    }

    private static string GetMapperName(GeneratorAttributeSyntaxContext ctx)
    {
        foreach (var attribute in ctx.Attributes)
        {
            if (!string.Equals(attribute.AttributeClass?.Name, "GeneratedMapperAttribute", StringComparison.Ordinal))
            {
                continue;
            }

            if (attribute.ConstructorArguments.Length == 1 && attribute.ConstructorArguments[0].Value is string mapperName)
            {
                return mapperName;
            }
        }

        return ctx.TargetSymbol.Name + "GeneratedMapper";
    }

    private static string GenerateMapperSource(INamedTypeSymbol typeSymbol, string mapperName)
    {
        var namespaceName = typeSymbol.ContainingNamespace.IsGlobalNamespace
            ? "DataAccessLayer.Mapping.Generated"
            : typeSymbol.ContainingNamespace.ToDisplayString();

        var properties = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.SetMethod is not null && p.SetMethod.DeclaredAccessibility == Accessibility.Public)
            .ToArray();

        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated />");
        builder.AppendLine("#nullable enable");
        builder.AppendLine("using System;");
        builder.AppendLine("using DataAccessLayer.Mapping;");
        builder.AppendLine("using System.Data.Common;");
        builder.AppendLine();
        builder.Append("namespace ").Append(namespaceName).AppendLine(";");
        builder.AppendLine();
        builder.Append("public sealed class ").Append(mapperName).Append(" : DataAccessLayer.Mapping.IDataMapper<").Append(typeSymbol.ToDisplayString()).AppendLine(">");
        builder.AppendLine("{");
        builder.AppendLine("    public ").Append(mapperName).AppendLine("() {}");
        builder.AppendLine();
        builder.AppendLine("    public ").Append(typeSymbol.ToDisplayString()).AppendLine(" Map(DbDataReader reader)");
        builder.AppendLine("    {");
        builder.AppendLine("        var instance = new ").Append(typeSymbol.ToDisplayString()).AppendLine("();");
        foreach (var prop in properties)
        {
            var propName = prop.Name;
            var ordinalVar = $"__{propName}Ordinal";
            builder.AppendLine($"        var {ordinalVar} = reader.GetOrdinal(\"{propName}\");");
            builder.AppendLine($"        if (!reader.IsDBNull({ordinalVar}))");
            builder.AppendLine("        {");
            builder.AppendLine($"            instance.{propName} = ({prop.Type.ToDisplayString()})reader.GetValue({ordinalVar});");
            builder.AppendLine("        }");
        }
        builder.AppendLine("        return instance;");
        builder.AppendLine("    }");
        builder.AppendLine("}");
        return builder.ToString();
    }
}
