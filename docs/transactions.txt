# Transaction Scenarios with the DAL Helper

## Feature Index
- Single-database transactions (sync + async)
- Multi-table atomic inserts (rollback on failure)
- Multi-database coordination (pseudo 2PC)
- Transaction scope options (Required / RequiresNew / Suppress)
- Savepoints per provider

## Multi-Procedure Unit of Work (Rollback on Failure)

Goal: execute multiple stored procedures from C# and ensure atomicity—if any command fails, everything rolls back; otherwise commit.

### Async Flow Example
```csharp
// resolve from DI
var transactionManager = scope.ServiceProvider.GetRequiredService<ITransactionManager>();
var db = scope.ServiceProvider.GetRequiredService<IDatabaseHelper>();

var procedureA = new DbCommandRequest
{
    CommandText = "dbo.FirstProcedure",
    CommandType = CommandType.StoredProcedure,
    Parameters = DbParameterCollectionBuilder.FromAnonymous(new { CustomerId = customerId })
};

var procedureB = new DbCommandRequest
{
    CommandText = "dbo.SecondProcedure",
    CommandType = CommandType.StoredProcedure,
    Parameters = DbParameterCollectionBuilder.FromAnonymous(new { CustomerId = customerId, Amount = amount })
};

await using var tx = await transactionManager.BeginAsync(cancellationToken: cancellationToken);

try
{
    await db.ExecuteAsync(procedureA with { Connection = tx.Connection, Transaction = tx.Transaction }, cancellationToken);
    await db.ExecuteAsync(procedureB with { Connection = tx.Connection, Transaction = tx.Transaction }, cancellationToken);

    await tx.CommitAsync(cancellationToken);
}
catch
{
    await tx.RollbackAsync(cancellationToken);
    throw;
}
```

### Sync Flow Example
```csharp
using var tx = transactionManager.Begin();

try
{
    db.Execute(procedureA with { Connection = tx.Connection, Transaction = tx.Transaction });
    db.Execute(procedureB with { Connection = tx.Connection, Transaction = tx.Transaction });
    tx.Commit();
}
catch
{
    tx.Rollback();
    throw;
}
```

### Notes
- `ITransactionManager` opens the connection via `IDbConnectionFactory` and supplies an `ITransactionScope` exposing `Connection`, `Transaction`, and savepoint helpers.
- `DbCommandRequest` is immutable; using C# `with` expressions lets you reuse the same request while supplying the ambient connection/transaction from the scope.
- If no explicit commit occurs, disposing the scope automatically rolls back and logs a warning.
- Savepoints: call `tx.BeginSavepoint("Step1")`, run commands, and roll back to the savepoint if necessary. Provider-specific SQL is handled internally (SQL Server/Oracle skip release, PostgreSQL emits RELEASE SAVEPOINT).
- ✅ Covered by `DatabaseHelperIntegrationTests.ExecuteAsync_ReusesExplicitTransactionAcrossMultipleTables` and `...WhenInsertFails_AllowsCallerToRollback`.

### Savepoints (ADO.NET + EF)
Savepoints are useful inside long-running scopes where you want to retry a smaller subset without rolling everything back. The DAL exposes synchronous and asynchronous helpers on every transaction scope:

```csharp
await using var tx = await transactionManager.BeginAsync();

await tx.BeginSavepointAsync("stage1");
try
{
    await db.ExecuteAsync(importBatch1 with { Connection = tx.Connection, Transaction = tx.Transaction }, cancellationToken);
    await tx.ReleaseSavepointAsync("stage1");
}
catch
{
    await tx.RollbackToSavepointAsync("stage1");
    // handle/log before retrying another batch
}

await tx.CommitAsync(cancellationToken);
```

The same APIs exist on the sync scope (`BeginSavepoint`, `RollbackToSavepoint`, `ReleaseSavepoint`). No provider-specific SQL is needed—the DAL issues the correct command for SQL Server (`SAVE TRANSACTION` / `ROLLBACK TRANSACTION`), PostgreSQL (`SAVEPOINT` / `ROLLBACK TO SAVEPOINT` / `RELEASE SAVEPOINT`), and Oracle (`SAVEPOINT` / `ROLLBACK TO SAVEPOINT`, release is implicit).

> ❗ Savepoint names must consist of letters, digits, `_`, or `-`; the helper sanitizes and validates names before sending them to the provider.

Async and sync savepoints are part of `ITransactionScope`, so EF scenarios work the same way. Just call the methods on the scope you already enlisted via `UseAmbientTransaction`.

## Coordinated Multi-Database Transactions (Archived)

The pseudo two-phase coordinator (`IMultiDbTransactionManager`, `IMultiDbTransactionScope`) has been removed from the active surface. If you depend on that behavior, copy the implementation from `Archive/MultiDbTransactions/` and enable it explicitly in your host.

## Built-in TransactionScope Options (Required, RequiresNew, Suppress)

`ITransactionManager.Begin()` and `BeginAsync()` both accept a `TransactionScopeOption` parameter (default `Required`). The helper now manages the ambient stack internally for both sync and async code paths, so dependent scopes just work without resorting to BCL `System.Transactions.TransactionScope`.

| Option | Behavior |
|--------|----------|
| `Required` (default) | Reuses the current ambient scope when one exists; otherwise creates a new connection/transaction. |
| `RequiresNew` | Always creates a brand-new connection + transaction, even when an ambient scope exists. |
| `Suppress` | Opens a provider connection without starting a transaction (autocommit mode). Useful for logging/outbox writes. |

### ADO.NET usage (async)
```csharp
var manager = scope.ServiceProvider.GetRequiredService<ITransactionManager>();
var db = scope.ServiceProvider.GetRequiredService<IDatabaseHelper>();

// Required (ambient reuse)
await using var outer = await manager.BeginAsync();
await db.ExecuteAsync(cmd with { Connection = outer.Connection, Transaction = outer.Transaction }, cancellationToken);

// RequiresNew
await using var audit = await manager.BeginAsync(scopeOption: TransactionScopeOption.RequiresNew);
await db.ExecuteAsync(auditCmd with { Connection = audit.Connection, Transaction = audit.Transaction }, cancellationToken);
await audit.CommitAsync(cancellationToken);

// Suppress
await using var noTx = await manager.BeginAsync(scopeOption: TransactionScopeOption.Suppress);
await db.ExecuteAsync(loggingCmd with { Connection = noTx.Connection, Transaction = null }, cancellationToken);
await noTx.CommitAsync(cancellationToken);

await outer.CommitAsync(cancellationToken);
```

### ADO.NET usage (sync)
```csharp
using var outer = manager.Begin();                               // Required
using var inner = manager.Begin(scopeOption: TransactionScopeOption.RequiresNew);
using var suppressed = manager.Begin(scopeOption: TransactionScopeOption.Suppress);

db.Execute(firstCmd with { Connection = outer.Connection, Transaction = outer.Transaction });
db.Execute(secondCmd with { Connection = inner.Connection, Transaction = inner.Transaction });
db.Execute(loggingCmd with { Connection = suppressed.Connection, Transaction = null });

inner.Commit();
suppressed.Commit();
outer.Commit();
```

### EF Core context sharing

1. **Required** – resolve the DbContext within the ambient scope and call `context.Database.UseTransaction(scope.Transaction)` once; subsequent `SaveChanges` join the outer scope.
2. **RequiresNew** – resolve a fresh DbContext after calling `Begin(scopeOption: TransactionScopeOption.RequiresNew)`, call `UseTransaction` with the new scope, perform the work, and commit/rollback that scope independently.
3. **Suppress** – skip `UseTransaction` entirely (or resolve a new DbContext) so EF goes back to autocommit mode for diagnostics/outbox writes.

Because the ambient stack flows through both sync and async code paths, dependent calls to `Begin/BeginAsync` automatically pick up the correct behavior without extra plumbing.

## Coverage Summary
- `ITransactionManager` + `ITransactionScope` for single-connection units of work and savepoints.
- `IDatabaseHelper` APIs accept `Connection`/`Transaction` from either scope, so all commands participate in the desired transaction.
- **Optional usage:** none of the DAL helpers *require* a transaction. If you omit `ITransactionScope`, `IDatabaseHelper`, EF contexts, and `IBulkWriteHelper` each open their own connection/command and rely on the provider’s auto-commit behavior. Use a scope only when you need atomicity across multiple operations.
- **EF Core guidance:** default queries should be `AsNoTracking()` when you are not mutating the entities; wrap `SaveChanges` inside `ITransactionScope` only when several write batches must commit together.
- `DatabaseOptions.Resilience` drives Polly-based retries/telemetry, covering both command execution and transaction commits/rollbacks.
- For idempotent transaction retries, ensure your updates can be replayed safely (e.g., use natural keys/UPSERTs). The DAL retries only connectivity/timeout errors; business logic should guard against double-execution. Use structured logging (Serilog integrated with Microsoft.Extensions.Logging) to capture transaction scopes, commits, and rollbacks for auditing.
