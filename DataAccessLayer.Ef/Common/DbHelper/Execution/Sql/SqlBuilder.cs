using System;
using System.Collections.Generic;
using System.Data;
using System.Globalization;
using System.Linq;
using System.Text;
using Shared.Configuration;

namespace DataAccessLayer.Execution;

/// <summary>
/// Fluent helper for composing parameterized SQL statements without manual string concatenation.
/// </summary>
public sealed class SqlBuilder
{
    private readonly List<string> _select = new();
    private readonly List<string> _joins = new();
    private readonly List<SqlClause> _where = new();
    private readonly List<string> _orderBy = new();
    private readonly List<DbParameterDefinition> _parameters = new();

    private string? _from;
    private bool _distinct;
    private int? _limit;
    private int? _offset;
    private int _parameterSeed;

    public static SqlBuilder Select(params string[] columns) => new SqlBuilder().SelectColumns(columns);

    public SqlBuilder Distinct(bool value = true)
    {
        _distinct = value;
        return this;
    }

    public SqlBuilder SelectColumns(params string[] columns)
    {
        if (columns is null)
        {
            return this;
        }

        foreach (var column in columns)
        {
            if (string.IsNullOrWhiteSpace(column))
            {
                continue;
            }

            _select.Add(SqlSafety.EnsureClause(column, nameof(columns)));
        }

        return this;
    }

    public SqlBuilder From(string source)
    {
        _from = string.IsNullOrWhiteSpace(source) ? _from : SqlSafety.EnsureClause(source, nameof(source));
        return this;
    }

    public SqlBuilder Join(string clause)
    {
        if (!string.IsNullOrWhiteSpace(clause))
        {
            _joins.Add(SqlSafety.EnsureClause(clause, nameof(clause)));
        }

        return this;
    }

    /// <summary>
    /// Adds a predicate using interpolated parameters so that values are automatically parameterized.
    /// </summary>
    /// <param name="predicate">Interpolated predicate (all holes become DAL parameters).</param>
    public SqlBuilder Where(FormattableString predicate)
    {
        _where.Add(CaptureClause(predicate));
        return this;
    }

    /// <summary>
    /// Adds a predicate when <paramref name="condition"/> is true.
    /// </summary>
    public SqlBuilder Where(bool condition, FormattableString predicate)
    {
        if (condition)
        {
            Where(predicate);
        }

        return this;
    }

    /// <summary>
    /// Adds a raw WHERE predicate that is assumed to be sanitized via <see cref="SqlSafety"/>.
    /// </summary>
    /// <remarks>
    /// Use this only for vetted fragments (e.g., generated by the application). Never concatenate user input here;
    /// prefer <see cref="Where(FormattableString)"/> so the builder can create parameters automatically.
    /// </remarks>
    public SqlBuilder WhereRaw(string clause)
    {
        if (!string.IsNullOrWhiteSpace(clause))
        {
            _where.Add(SqlClause.Raw(SqlSafety.EnsureClause(clause, nameof(clause))));
        }

        return this;
    }

    /// <summary>
    /// Appends an ORDER BY expression that has been validated (e.g., via <see cref="SqlSafety.EnsureClause"/>).
    /// </summary>
    /// <remarks>
    /// ORDER BY cannot be parameterized by providers, so ensure the expression comes from a trusted list
    /// before invoking this API.
    /// </remarks>
    public SqlBuilder OrderBy(string expression)
    {
        if (!string.IsNullOrWhiteSpace(expression))
        {
            _orderBy.Add(SqlSafety.EnsureClause(expression, nameof(expression)));
        }

        return this;
    }

    public SqlBuilder Limit(int limit)
    {
        _limit = limit >= 0 ? limit : null;
        return this;
    }

    public SqlBuilder Offset(int offset)
    {
        _offset = offset >= 0 ? offset : null;
        return this;
    }

    public SqlBuilder Paginate(int pageNumber, int pageSize)
    {
        if (pageNumber < 1 || pageSize < 1)
        {
            return this;
        }

        _limit = pageSize;
        _offset = (pageNumber - 1) * pageSize;
        return this;
    }

    public SqlBuilder AddParameter(DbParameterDefinition definition)
    {
        ArgumentNullException.ThrowIfNull(definition);
        if (string.IsNullOrWhiteSpace(definition.Name))
        {
            throw new ArgumentException("Parameter name is required.", nameof(definition));
        }

        _parameters.Add(definition);
        return this;
    }

    public SqlBuilderResult Build(DatabaseProvider provider)
    {
        if (string.IsNullOrWhiteSpace(_from))
        {
            throw new InvalidOperationException("FROM clause is required.");
        }

        var sql = new StringBuilder();
        sql.Append("SELECT ");
        if (_distinct)
        {
            sql.Append("DISTINCT ");
        }

        sql.Append(_select.Count > 0 ? string.Join(", ", _select) : "*");
        sql.Append(" FROM ").Append(_from);

        foreach (var join in _joins)
        {
            sql.Append(' ').Append(join);
        }

        if (_where.Count > 0)
        {
            sql.Append(" WHERE ");
            var rendered = _where.Select(clause => clause.Render(provider));
            sql.Append(string.Join(" AND ", rendered));
        }

        if (_orderBy.Count > 0)
        {
            sql.Append(" ORDER BY ").Append(string.Join(", ", _orderBy));
        }

        AppendPagination(sql, provider);

        return new SqlBuilderResult(sql.ToString(), provider, _parameters.AsReadOnly());
    }

    private void AppendPagination(StringBuilder sql, DatabaseProvider provider)
    {
        if (_limit is null && _offset is null)
        {
            return;
        }

        if (_orderBy.Count == 0 && RequiresOrderBy(provider) && (_offset.HasValue || _limit.HasValue))
        {
            sql.Append(" ORDER BY (SELECT 1)");
        }

        var limitValue = _limit ?? 0;
        var offsetValue = _offset ?? 0;

        switch (provider)
        {
            case DatabaseProvider.SqlServer:
            case DatabaseProvider.Oracle:
                sql.Append(" OFFSET ").Append(offsetValue).Append(" ROWS");
                if (limitValue > 0)
                {
                    sql.Append(" FETCH NEXT ").Append(limitValue).Append(" ROWS ONLY");
                }
                break;
            default:
                if (limitValue > 0)
                {
                    sql.Append(" LIMIT ").Append(limitValue);
                }

                if (offsetValue > 0)
                {
                    sql.Append(" OFFSET ").Append(offsetValue);
                }
                break;
        }

    }

    private bool RequiresOrderBy(DatabaseProvider provider) =>
        provider is DatabaseProvider.SqlServer or DatabaseProvider.Oracle;

    private SqlClause CaptureClause(FormattableString fragment)
    {
        if (fragment is null)
        {
            throw new ArgumentNullException(nameof(fragment));
        }

        var arguments = fragment.GetArguments();
        var parameterNames = new string[arguments.Length];
        for (var i = 0; i < arguments.Length; i++)
        {
            var parameterName = $"p{_parameterSeed++}";
            parameterNames[i] = parameterName;
            _parameters.Add(CreateParameter(parameterName, arguments[i]));
        }

        return new SqlClause(fragment.Format, parameterNames);
    }

    private static DbParameterDefinition CreateParameter(string name, object? value)
    {
        if (value is DbParameterDefinition definition)
        {
            return CloneParameter(definition, name);
        }

        return DbParameterCollectionBuilder.Input(name, value);
    }

    private static DbParameterDefinition CloneParameter(DbParameterDefinition source, string name) =>
        new()
        {
            Name = name,
            Value = source.Value,
            DbType = source.DbType,
            Direction = source.Direction,
            Size = source.Size,
            Precision = source.Precision,
            Scale = source.Scale,
            IsNullable = source.IsNullable,
            DefaultValue = source.DefaultValue,
            ProviderTypeName = source.ProviderTypeName,
            TreatAsList = source.TreatAsList,
            Values = source.Values,
            ValueConverter = source.ValueConverter
        };

    private readonly struct SqlClause
    {
        private readonly string _template;
        private readonly string[] _parameterNames;

        internal SqlClause(string template, string[] parameterNames)
        {
            _template = template;
            _parameterNames = parameterNames;
        }

        public static SqlClause Raw(string value) => new(value, Array.Empty<string>());

        public string Render(DatabaseProvider provider)
        {
            if (_parameterNames.Length == 0)
            {
                return _template;
            }

            var replacements = new object[_parameterNames.Length];
            for (var i = 0; i < _parameterNames.Length; i++)
            {
                replacements[i] = GetToken(provider, _parameterNames[i]);
            }

            return string.Format(CultureInfo.InvariantCulture, _template, replacements);
        }

        private static string GetToken(DatabaseProvider provider, string name) =>
            provider switch
            {
                DatabaseProvider.Oracle => $":{name}",
                DatabaseProvider.PostgreSql => $"@{name}",
                _ => $"@{name}"
            };
    }
}
